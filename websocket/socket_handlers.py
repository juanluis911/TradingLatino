"""
Handlers para eventos de Socket.IO
"""
from flask_socketio import emit, disconnect
from flask import request
from services.analysis_service import analysis_service
from utils.logger import websocket_logger
from utils.json_utils import debug_json_serialization, clean_analysis_dict
from config import Config
import threading
import time

logger = websocket_logger

class SocketHandlers:
    """
    Manejadores de eventos Socket.IO
    """
    
    def __init__(self, socketio):
        """
        Inicializa los handlers con la instancia de socketio
        
        Args:
            socketio: Instancia de Flask-SocketIO
        """
        self.socketio = socketio
        self.analysis_service = analysis_service
        self.connected_clients = set()
        self.analysis_cache = {}
        logger.info("üîå Socket handlers inicializados")
    
    def register_handlers(self):
        """Registra todos los event handlers"""
        
        @self.socketio.on('connect')
        def handle_connect():
            """Maneja la conexi√≥n de un nuevo cliente"""
            client_id = request.sid
            self.connected_clients.add(client_id)
            
            logger.info(f"‚úÖ Cliente conectado: {client_id} (Total: {len(self.connected_clients)})")
            
            # Enviar mensaje de bienvenida
            emit('status', {
                'msg': 'Conectado al servidor de an√°lisis - Metodolog√≠a Jaime Merino',
                'timestamp': time.time(),
                'symbols_available': Config.TRADING_SYMBOLS
            })
            
            # Enviar an√°lisis en cache si existen
            self._send_cached_analysis(client_id)
        
        @self.socketio.on('disconnect')
        def handle_disconnect():
            """Maneja la desconexi√≥n de un cliente"""
            client_id = request.sid
            self.connected_clients.discard(client_id)
            
            logger.info(f"‚ùå Cliente desconectado: {client_id} (Total: {len(self.connected_clients)})")
        
        @self.socketio.on('request_analysis')
        def handle_request_analysis(data):
            """
            Maneja solicitudes de an√°lisis para s√≠mbolos espec√≠ficos
            
            Args:
                data: Dict con 'symbol' y opcionalmente otros par√°metros
            """
            try:
                client_id = request.sid
                symbol = data.get('symbol', 'BTCUSDT').upper()
                
                # Validar s√≠mbolo
                if symbol not in Config.TRADING_SYMBOLS:
                    logger.warning(f"‚ö†Ô∏è S√≠mbolo no soportado solicitado: {symbol} por {client_id}")
                    emit('analysis_error', {
                        'symbol': symbol,
                        'error': f'S√≠mbolo {symbol} no est√° en la lista de s√≠mbolos soportados',
                        'supported_symbols': Config.TRADING_SYMBOLS
                    })
                    return
                
                logger.info(f"üìä An√°lisis solicitado: {symbol} por cliente {client_id}")
                
                # Realizar an√°lisis en hilo separado para no bloquear
                analysis_thread = threading.Thread(
                    target=self._process_analysis_request,
                    args=(symbol, client_id)
                )
                analysis_thread.daemon = True
                analysis_thread.start()
                
            except Exception as e:
                logger.error(f"‚ùå Error procesando solicitud de an√°lisis: {e}")
                emit('analysis_error', {
                    'symbol': data.get('symbol', 'UNKNOWN'),
                    'error': f'Error procesando solicitud: {str(e)}'
                })
        
        @self.socketio.on('request_all_symbols')
        def handle_request_all_symbols():
            """Solicita an√°lisis para todos los s√≠mbolos configurados"""
            try:
                client_id = request.sid
                logger.info(f"üìä An√°lisis de todos los s√≠mbolos solicitado por {client_id}")
                
                # Procesar todos los s√≠mbolos en hilo separado
                all_symbols_thread = threading.Thread(
                    target=self._process_all_symbols_request,
                    args=(client_id,)
                )
                all_symbols_thread.daemon = True
                all_symbols_thread.start()
                
            except Exception as e:
                logger.error(f"‚ùå Error procesando solicitud de todos los s√≠mbolos: {e}")
                emit('analysis_error', {
                    'error': f'Error procesando solicitud completa: {str(e)}'
                })
        
        @self.socketio.on('ping')
        def handle_ping():
            """Responde a ping del cliente para mantener conexi√≥n"""
            emit('pong', {'timestamp': time.time()})
        
        @self.socketio.on('get_server_status')
        def handle_get_server_status():
            """Env√≠a el estado del servidor"""
            try:
                status = {
                    'connected_clients': len(self.connected_clients),
                    'cached_analyses': len(self.analysis_cache),
                    'supported_symbols': Config.TRADING_SYMBOLS,
                    'update_interval': Config.UPDATE_INTERVAL,
                    'server_time': time.time(),
                    'binance_connection': self.analysis_service.binance.test_connection()
                }
                
                emit('server_status', status)
                logger.debug(f"üìä Estado del servidor enviado a {request.sid}")
                
            except Exception as e:
                logger.error(f"‚ùå Error obteniendo estado del servidor: {e}")
                emit('server_status', {'error': str(e)})
    
    def _process_analysis_request(self, symbol: str, client_id: str):
        """
        Procesa una solicitud de an√°lisis en hilo separado
        
        Args:
            symbol: S√≠mbolo a analizar
            client_id: ID del cliente que solicit√≥
        """
        try:
            # Realizar an√°lisis
            analysis = self.analysis_service.analyze_symbol(symbol)
            
            if analysis:
                # Convertir a diccionario y limpiar
                analysis_dict = analysis.to_dict()
                
                # Debug de serializaci√≥n
                if not debug_json_serialization(analysis_dict, f"an√°lisis de {symbol}"):
                    logger.warning(f"‚ö†Ô∏è Problemas de serializaci√≥n detectados para {symbol}")
                    analysis_dict = clean_analysis_dict(analysis_dict)
                
                # Cachear an√°lisis
                self.analysis_cache[symbol] = analysis_dict
                
                # Enviar a todos los clientes conectados
                self.socketio.emit('analysis_update', {
                    'symbol': symbol,
                    'data': analysis_dict,
                    'timestamp': time.time()
                })
                
                logger.info(f"‚úÖ An√°lisis enviado para {symbol}")
                
            else:
                # Error en an√°lisis
                self.socketio.emit('analysis_error', {
                    'symbol': symbol,
                    'error': 'No se pudo completar el an√°lisis t√©cnico',
                    'details': 'Verifique la conexi√≥n con Binance o intente m√°s tarde'
                })
                
                logger.error(f"‚ùå An√°lisis fall√≥ para {symbol}")
                
        except Exception as e:
            logger.error(f"‚ùå Error en hilo de an√°lisis para {symbol}: {e}")
            import traceback
            logger.error(traceback.format_exc())
            
            self.socketio.emit('analysis_error', {
                'symbol': symbol,
                'error': f'Error interno: {str(e)}'
            })
    
    def _process_all_symbols_request(self, client_id: str):
        """
        Procesa solicitud de an√°lisis para todos los s√≠mbolos
        
        Args:
            client_id: ID del cliente que solicit√≥
        """
        try:
            logger.info(f"üîÑ Procesando an√°lisis completo para cliente {client_id}")
            
            # Notificar inicio
            self.socketio.emit('bulk_analysis_started', {
                'symbols': Config.TRADING_SYMBOLS,
                'total': len(Config.TRADING_SYMBOLS)
            }, room=client_id)
            
            completed = 0
            
            for symbol in Config.TRADING_SYMBOLS:
                try:
                    # Peque√±a pausa entre an√°lisis para no sobrecargar
                    time.sleep(0.5)
                    
                    analysis = self.analysis_service.analyze_symbol(symbol)
                    
                    if analysis:
                        analysis_dict = analysis.to_dict()
                        
                        # Limpiar si es necesario
                        if not debug_json_serialization(analysis_dict, f"an√°lisis bulk {symbol}"):
                            analysis_dict = clean_analysis_dict(analysis_dict)
                        
                        # Cachear y enviar
                        self.analysis_cache[symbol] = analysis_dict
                        
                        self.socketio.emit('analysis_update', {
                            'symbol': symbol,
                            'data': analysis_dict,
                            'timestamp': time.time(),
                            'bulk_progress': {
                                'completed': completed + 1,
                                'total': len(Config.TRADING_SYMBOLS)
                            }
                        })
                        
                        completed += 1
                        logger.debug(f"‚úÖ An√°lisis bulk completado: {symbol} ({completed}/{len(Config.TRADING_SYMBOLS)})")
                        
                    else:
                        logger.warning(f"‚ö†Ô∏è An√°lisis bulk fall√≥ para {symbol}")
                        
                except Exception as e:
                    logger.error(f"‚ùå Error en an√°lisis bulk para {symbol}: {e}")
                    continue
            
            # Notificar finalizaci√≥n
            self.socketio.emit('bulk_analysis_completed', {
                'completed': completed,
                'total': len(Config.TRADING_SYMBOLS),
                'success_rate': (completed / len(Config.TRADING_SYMBOLS)) * 100
            }, room=client_id)
            
            logger.info(f"üèÅ An√°lisis bulk completado: {completed}/{len(Config.TRADING_SYMBOLS)} s√≠mbolos")
            
        except Exception as e:
            logger.error(f"‚ùå Error en an√°lisis bulk: {e}")
            self.socketio.emit('bulk_analysis_error', {
                'error': str(e)
            }, room=client_id)
    
    def _send_cached_analysis(self, client_id: str):
        """
        Env√≠a an√°lisis en cache a un cliente reci√©n conectado
        
        Args:
            client_id: ID del cliente
        """
        try:
            if self.analysis_cache:
                logger.info(f"üì§ Enviando {len(self.analysis_cache)} an√°lisis en cache a {client_id}")
                
                for symbol, analysis_data in self.analysis_cache.items():
                    self.socketio.emit('analysis_update', {
                        'symbol': symbol,
                        'data': analysis_data,
                        'timestamp': time.time(),
                        'cached': True
                    }, room=client_id)
                    
                    # Peque√±a pausa para evitar saturar
                    time.sleep(0.1)
            else:
                logger.debug(f"üì≠ No hay an√°lisis en cache para enviar a {client_id}")
                
        except Exception as e:
            logger.error(f"‚ùå Error enviando cache a {client_id}: {e}")
    
    def broadcast_analysis_update(self, symbol: str, analysis_data: dict):
        """
        Env√≠a actualizaci√≥n de an√°lisis a todos los clientes conectados
        
        Args:
            symbol: S√≠mbolo actualizado
            analysis_data: Datos del an√°lisis
        """
        try:
            if self.connected_clients:
                # Limpiar datos antes de enviar
                clean_data = clean_analysis_dict(analysis_data.copy())
                
                self.socketio.emit('analysis_update', {
                    'symbol': symbol,
                    'data': clean_data,
                    'timestamp': time.time(),
                    'broadcast': True
                })
                
                # Actualizar cache
                self.analysis_cache[symbol] = clean_data
                
                logger.info(f"üì° An√°lisis broadcast para {symbol} a {len(self.connected_clients)} clientes")
            else:
                logger.debug(f"üì≠ No hay clientes conectados para broadcast de {symbol}")
                
        except Exception as e:
            logger.error(f"‚ùå Error en broadcast para {symbol}: {e}")
    
    def clear_analysis_cache(self):
        """Limpia el cache de an√°lisis"""
        self.analysis_cache.clear()
        logger.info("üóëÔ∏è Cache de an√°lisis limpiado")
    
    def get_connected_clients_count(self) -> int:
        """Retorna el n√∫mero de clientes conectados"""
        return len(self.connected_clients)